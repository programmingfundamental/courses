---
layout: default
title: Лабораторно упражнение 1
parent: Обектно-ориентирано програмиране - 2 част
has_children: true
nav_order: 1
permalink: /docs/obektno-orientirano-programirane-2-chast/laboratorno-uprazhnenie-1
---

# Лабораторно упражнение 1

### Принципите SOLID

Принципите SOLID са въведени от Робърт Ч. Мартин в неговия труд от 2000 г. "Принципи на дизайна и модели на дизайна". Това понятие по-късно са надградено от Майкъл Пера, който въвежда акронима SOLID. През последните 20 години тези пет принципа революционизираха света на обектно-ориентираното програмиране, променяйки начина, по който се пише софтуер.

Какво е **SOLID** и как помага за писането на по-добър код?

Казано по-просто, дизайнерските принципи на Мартин и Пера **насърчават създаването на по-лесен за поддържане, разбираем и гъвкав софтуер.** Следователно, въпреки **неизбежноста от това, че приложенията растат по размер, тяхната сложност намалява**!


Принципите на SOLID указват как да бъдат подредим функциите и структурите от данни в класове и как тези класове трябва да бъдат свързани помежду си.

Използването на думата „клас” не означава, че тези принципи са приложими само към обектно-ориентираното програмиране. Класът е просто свързано групиране на функции и данни. Всяка софтуерна система има такива групи, независимо дали се наричат класове или не. Принципите на SOLID се прилагат за тези групи от функции и данни и дори до по-ниско ниво като функция или структура от данни, които ще наричаме елементи/елементи на софтуера

Следните пет понятия съставляват **SOLID** принципите:

<table><thead><tr><th width="119.4">Инициал</th><th width="188">Акроними</th><th>Концепция</th></tr></thead><tbody><tr><td>S</td><td>SRP - <strong>Single Responsibility Principle</strong></td><td><strong>Принцип за единствена отговорност</strong><br>Това ще рече, че всеки елемент на софтуера има единствено предназначение и само една причина за промяна.</td></tr><tr><td>O</td><td>OCP - <strong>Open-Closed Principle</strong></td><td><p><strong>Принципът отворено-затворено</strong></p><p>Същността е, че за да бъдат лесни за промяна всички елемент на софтуера,  трябва да бъдат проектирани така, че да позволяват поведението на елементите да бъде променено чрез добавяне на нов код, а не промяна на съществуващ код.</p></td></tr><tr><td>L</td><td>LSP - <strong>Liskov Substitution Principle</strong></td><td><p><strong>Принцип на заместване на Лисков</strong></p><p>Всеки наследник (подтип) трябва лесно да заменя всичките си базови типове.</p></td></tr><tr><td>I</td><td>ISP - <strong>Interface Segregation Principle</strong></td><td><p><strong>Принцип за разделяне на интерфейсите</strong></p><p>Много на брой малки интерфейси е по-добре от един голям общ интерфейс. Това означава, че не е нужно даден код да зависи от неща, които не се използват</p></td></tr><tr><td>D</td><td>DIP - <strong>Dependency Inversion Principle</strong></td><td><p><strong>Принцип на обръщане на зависимостите</strong></p><p>Всички класове от високо ниво трябва да дефинират абстракции и нито един не трябва да зависи от конкретен клас. Класовете от ниско ниво може да зависят от абстракциите.</p></td></tr></tbody></table>
