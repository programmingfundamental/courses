# Main клас в Spring Boot

В генерирания проект можете да откриете, че Spring Initializr е генерирал Java клас с Java main() метод в него.

```java
package com.manning.sbip.ch01;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootAppDemoApplication {
      public static void main(String[] args) {
             SpringApplication.run(SpringBootAppDemoApplication.class, args);
      }
}
```

Нека разгледаме следните компоненти на генерирания Java файл:

1\.    Метода main().

2\.    Употребата на анотацията @SpringBootApplication

3\.    Ролята на класа SpringApplication

### Методът main()

За да стартирате уеб приложение, вие изграждате и пакетирате компонентите на приложението в WAR или EAR архивен файл и го използвате в мрежата (напр. в Apache Tomcat) или на application сървър (напр. Red Hat JBoss). Spring Boot опростява този процес до известна степен. Не ви принуждава да създавате WAR или EAR файл за вашето приложение. Вместо това ви позволява да стартирате приложението Spring Boot като обикновено Java приложение, използвайки конвенционален main() метод.

Въпреки че Spring Boot следва познатия подход “Keep it simple”, за да направи нещата прости за разработчиците, изпълнява голямо количество тежка работа зад кулисите. Например базирано на сървлет уеб приложение може да работи само в контейнер като Apache Tomcat или Jetty. Spring Boot позволява тази поддръжка чрез използването на вграден Apache Tomcat сървър в приложението по подразбиране. По този начин при стартиране на приложението, използвайки метода main(), Spring Boot стартира вградена инстанция на Apache Tomcat сървър и изпълнява уеб приложението вътре в него. Ако проучите допълнително зависимостта spring-boot-starter-web, можете да откриете транзитивна зависимост към модула spring-boot-starter-tomcat.

### Анотацията @SpringBootApplication

Може да забележите, че класът в генерирания Java файл е анотиран с @SpringBootApplication анотация. Това е удобна анотация, която съдържа в себе си три анотации: @EnableAutoConfiguration, @ComponentScan и @SpringBootConfiguration, всяка от които изпълнява специфична задача в приложението:

* **@EnableAutoConfiguration** – осигурява необходимата поддръжка за автоматично конфигуриране на приложението въз основа на наличните JAR зависимости в неговия classpath.
* **@ComponentScan** - осигурява поддръжка за сканиране на пакетите за Spring компоненти. Компонент в Spring е Java bean, който се управлява от Spring и е антотиран с @Component, @Bean или друга специализирана анотация за компонент.  При наличието на анотация @ComponentScan, Spring Boot приложението сканира за идентифицирането на всички компоненти, присъстващи в основния пакет и подпакети под него, за да управлява впоследствие техния жизнен цикъл.&#x20;
* **@SpringBootConfiguration** - показва, че този клас е Spring конфигурационен клас. Той е мета-анотиран със Spring @Configuration анотация, така че конфигурациите в анотирания клас могат да бъдат намерени автоматично от Spring Boot. &#x20;

Имайте предвид, че основният клас на Spring Boot приложението трябва да се намира в root пакета, тъй като анотацията @SpringBootApplication е конфигурирана в този клас. @SpringBootApplication анотацията използва основния пакет като базов пакет. Така базовият пакет и всички други подпакети се сканират автоматично от Spring Boot за зареждане на Spring компоненти (напр. класове, конфигурирани с @Component, @Configuration и други Spring анотации) и други типове. &#x20;

### Класът SpringApplication

Следващият и последен компонент е използването на SpringApplication в генерирания Java файл. Този клас се предоставя от Spring Boot за удобно зареждане на Spring Boot приложение. През повечето време ще използвате статичния метод run() на SpringApplication, за да стартирате вашето приложение. Spring Boot изпълнява няколко дейности, докато изпълнява метода run():

1\.    Създава екземпляр на ApplicationContext въз основа на библиотеките, присъстващи в classpath

2\.    Регистрира CommandLinePropertySource, за да изложи аргументите на командния ред като свойства на Spring

3\.    Опреснява ApplicationContext, създаден в стъпка 1, за да зареди всички сингълтон beans

4\.    Задейства ApplicationRunners и CommandRunners, конфигурирани в приложението

#### ApplicationContext

Повечето Java приложения, които разработвате, се състоят от обекти. Тези обекти взаимодействат помежду си и между тях съществуват зависимости. За да управлява ефективно създаването на обекти и взаимозависимостите, Spring използва принципа за инжектиране на зависимости (DI). Това инжектиране на зависимости или подход за инверсия на управлението (IoC) позволява на Spring да създава обектите (или beans на езика на Spring) и да инжектира зависимостите външно. Дефинициите на bean се представят на Spring или чрез файловете с дефиниции на XML bean (напр. applicationContext.xml), или чрез базираните на анотации конфигурации (@Configuration анотация). Spring зарежда bean дефинициите и ги поддържа налични в Spring IoC контейнера. Интерфейсът ApplicationContext действа като Spring IoC контейнер. Spring предоставя изобилие от имплементации на ApplicationContext въз основа на типа на приложението (Servlet или Reactive приложение), конфигурациите на дефинициите на beans (напр. за зареждане от classpath или анотация) и т.н. &#x20;

Класът SpringApplication се опитва да създаде екземпляр на ApplicationContext въз основа на JAR зависимостите, присъстващи в classpath. Уеб приложението Spring Boot може да бъде базирано на сървлет или реактивен тип. Използвайки техниките за зареждане на класове на Spring и въз основа на наличността на класовете в classpath, Spring извежда типа на текущото приложение. След като типът на приложението е известен, Spring Boot прилага стратегията по-долу, за да зареди контекста на приложението:

* Ако приложението е идентифицирано като уеб приложение, базирано на Servlet, Spring Boot се опитва да създаде екземпляр на клас AnnotationConfigServletWebServerApplicationContext.
* Ако приложението е от реактивен тип, Spring Boot създава екземпляр на класа AnnotationConfigReactiveWebServerApplicationContext.
* Ако приложението не е нито базирано на Servlet, нито реактивно, Spring Boot се опитва да създаде екземпляр на клас AnnotationConfigApplicationContext.

Spring Boot приложението се стартира като използвате статичния метод run() на класа SpringApplication. Въпреки че използването на статичния метод run() е полезно, Spring Boot допълнително ви позволява да създадете екземпляр на клас SpringApplication, за да персонализирате режима за стартиране на приложението. Например, ако знаете типа на приложението, можете директно да го зададете в екземпляра SpringApplication, както е показано по-долу.

<figure><img src="../../../.gitbook/assets/image (65).png" alt=""><figcaption></figcaption></figure>

SpringApplication също така предоставя няколко метода за настройка, така че можете да контролирате различни функции на Spring Boot, като например задаване на допълнителни Spring профили или задаване на средство за зареждане на ресурси.
