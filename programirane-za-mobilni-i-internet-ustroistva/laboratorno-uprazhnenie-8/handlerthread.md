# HandlerThread

HandlerThread  е удобен клас за стартиране на нова работна нишка, която **последователно изпълнява задачи.**&#x20;

HandlerThread инициира Looper в нишка за обработка на Runnable или Message

```
//Създайте нова фонова нишка за последователна обработка на Runnable или Message
HandlerThread handlerThread = new HandlerThread("HandlerThreadName");
// Стартира фоновата нишка 
handlerThread.start();
// Създайте HandlerThread Looper, манипулатор
mHandler = new Handler(handlerThread.getLooper()) {
    @Override
    public void handleMessage(Message msg) {
        // Обработвяане на получените съобщения
    }
};
```

### Изпълнение на Runnables в HandlerThread

След като HandlerThread  е стасртиран може да изпълнява кода в работната нижка чрез Handler

```
// Изпълнява посочения код в работната нижка
mHandler.post(new Runnable() {
    @Override
    public void run() {
        // Кодът, който ще се изпълни в нишка
    }
});
```

В горния код извикваме метода post на манипулатора, за да поставим Runnable, който да бъде изпълнен възможно най-скоро. Класът Handler поддържа няколко други начина за планиране на Runnable за обработка в бъдеще:

| Метод                | Описание                                                                            |
| -------------------- | ----------------------------------------------------------------------------------- |
| `post`               | Веднага изпратете в опашка Runnable за възможно най-ранно изпълнение.               |
| `postAtTime`         | Поставяне в опашката Runnable за изпълни в абсолютно време, определен в милисекунди |
| `postDelayed`        | Поставяне в опашката Runnable за изпълни след определеното закъснение в милисекунди |
| `postAtFrontOfQueue` | Веднага поставете в опашка Runnable най-отпред отпред, за да бъде изпълнен.         |

### Обработка на Messages в HandlerThread

Вместо да изпълнява произволен код на фоновата нишка с помощта на Runnable, както е показано по-горе, Handler може също да изпраща съобщения в опашка с пакетирана информация. За да изпратите съобщение на работната нишка през манипулатора:

```
// Защитете ново съобщение за изпращане 
Message message = handler.obtainMessage();
// Създайте пакет
Bundle b = new Bundle();
b.putString("message", "new");
// прикачете манипулатора към съобщението 
message.setData(b);
// Изпратете съобщение чрез манипулатора 
mHandler.sendMessage(message);
// или вместо това изпратете празно съобщение с
// mHandler.sendEmptyMessage(0);
```

В горния код извикваме метода sendMessage на манипулатора, за да изпратим в опашка съобщение, което да бъде обработено възможно най-скоро. Класът Handler поддържа няколко други начина за планиране на обработка на съобщение в бъдеще:

| Метод                     | Описание                                                                               |
| ------------------------- | -------------------------------------------------------------------------------------- |
| `sendMessage`             | Избутва съобщение в края на опашката за съобщения.                                     |
| `sendMessageDelayed`      | Изпраща съобщение, което трябва да бъде доставено след изтичане на определеното време. |
| `sendMessageAtTime`       | Изпраща съобщение, което трябва да бъде доставено в посочения абсолютен час.           |
| `sendEmptyMessage`        | Изпраща съобщение, съдържащо само един int код.                                        |
| `sendEmptyMessageDelayed` | Изпраща съобщение, което трябва да бъде доставено след изтичане на определеното време. |
| `sendEmptyMessageAtTime`  | Изпраща съобщение, което трябва да бъде доставено в посочения абсолютен час.           |

Празни съобщения могат да се използват за обикновени манипулатори, получаващи съобщение от типа „опресняване“ или „уведомяване“, което не изисква допълнителни данни.

### Messages срещу Runnables?&#x20;

Често целта на Handler да приеме както Runnable, така и Message се поставя под въпрос. Имайте предвид, че Runnable е просто Messages, съхраняващо кодовия блок и че и двете се съдържат в една и съща опащка MessageQueue, която трябва да бъде обработена. Едно предимство на Messages е, че изпраща съощение което не е задължително да знае нещо за изпълнението, което може да позволи по-добро капсулиране.

### Спиране на **HandlerThread**

Работната нишка може да бъде спряна незабавно с:

```
handlerThread.quit(); // quits immediately
```

В API> = 18, вместо това трябва да използваме quitSafely (), за да завършим обработката на чакащите съобщения, преди да бъде спряна задачата.

HandleThread задачите могат да се изпълняват паралелно на потребителската нишка но не и паралелно по можду си.
